# Working with notebooks

In a Calkit project, notebooks are used to generate evidence
to support conclusions or answers to research questions.
Their interactive nature makes them ideal for prototyping,
data exploration, and fast iteration on smaller chunks of an analysis
workflow.
However, this interactivity can make reproducibility a challenge.

Jupyter notebooks are great for prototyping and data exploration,
but can also be useful in generating evidence to support answers to
research questions.
In fact, for software prototyping, an executed notebook can be evidence
itself---evidence that answers questions regarding an idea's feasibility,
scalability, performance, etc.
In research projects, typically data and results may be explored interactively
in a notebook, with some figures and tables saved to be included in
a PDF of a research article.

To be clear, here we're not talking about using notebooks to build interactive
[apps](apps.md).
For that, a standard Jupyter notebook is probably not the best tool.
If you're looking to build an app to allow others to interact
with your data and/or results, check out
[marimo](https://marimo.io/),
[Dash](https://dash.plotly.com/),
[Streamlit](https://streamlit.io/),
[Panel](https://panel.holoviz.org/),
[Voila](https://voila.readthedocs.io/en/stable/),
[Gradio](https://www.gradio.app/),
or any of the others in this popular space.

So, here we're talking about using notebooks to generate
evidence to support research conclusions.
Calkit seeks to make it easier to incorporate notebooks into a
reproducible research project.

TODO: Talk about when and how to do interactive work.
For example, if you need to tweak a figure,
you can keep tweaking the cell that generates the figure,
but you'll want to ensure the version used in the paper is generated
with the pipeline.
That's reproducibility.

TODO: Talk about reproducibility crisis.

However, to keep a project reproducible, i.e., all evidence is generated
with a single command,
it's not okay to save TODO.

If a notebook is used to generate figures interactively, for example,
that is by definition leading to a non-reproducible project.

If you want to use a notebook to generate evidence to support conclusions
of a research project,
you'll want to follow a few rules:

1. The notebook must be kept in version control, ideally with its outputs
   removed. This can be done by installing `nbstripout` and running
   `nbstripout --install` in the project directory.
1. A notebook must run in one of the project's [environments](environments.md).
1. Since all of the project's output artifacts should be generated as part
   of the [pipeline](pipeline/index.md), notebooks are no exception.
   It's fine to do some ad hoc work interactively to get the notebook
   working properly, but
   "official" outputs should be generated by calling `calkit run`.
   We'll see how below.

## Creating an environment for a notebook

Assuming you want to run Python in the notebook, you can create an environment
for it with `uv`, `venv`, `conda`, or `pixi`.
For example, if we wanted to create a new `uv-venv` called `py` in our project,
we can execute:

```sh
calkit new uv-venv \
    --name py \
    --prefix .venv \
    --python 3.13 \
    --path requirements.txt \
    jupyter \
    "pandas>=2" \
    numpy \
    plotly \
    matplotlib \
    polars
```

You can then start JupyterLab in this environment with
`calkit xenv -n py jupyter lab`.

## Adding a notebook to the pipeline

A notebook can be added to the pipeline by editing `calkit.yaml` directly,
using a `jupyter-notebook` stage.
For example:

```yaml
# In calkit.yaml
environments:
  py:
    kind: uv-venv
    prefix: .venv
    python: "3.13"
    path: requirements.txt
pipeline:
  stages:
    my-notebook:
      kind: jupyter-notebook
      environment: py
      notebook_path: notebooks/get-data.ipynb
      outputs:
        - data/raw/data.csv
      html_storage: dvc
      executed_ipynb_storage: null
      cleaned_ipynb_storage: git
# Optional: Add to project notebooks so they can be viewed on Calkit Cloud
notebooks:
  - path: notebooks/get-data.ipynb
    title: Get data
    stage: my-notebook
```

This can also be done inside a notebook with the `declare_notebook` function,
which will update `calkit.yaml` automatically.

```python
import calkit

calkit.declare_notebook(
    path="notebooks/get-data.ipynb",
    stage_name="my-notebook",
    environment_name="py",
    outputs=["data/raw/data.csv"],
    html_storage="dvc",
    executed_ipynb_storage=None,
    cleaned_ipynb_storage="git",
)
```

Note that for this to run properly `calkit-python` must be installed in
the notebook's environment, which in this case is named `py` and whose
packages are listed in `requirements.txt`.
If we didn't include them when creating the environment,
we can simply add `calkit-python` to the `requirements.txt` file and rerun
`calkit xenv -n py jupyter lab`.
The environment will be updated before starting JupyterLab.

## Expensive cells

Sometimes it can get painful restarting and rerunning a notebook over and over
again.
TODO: More.
