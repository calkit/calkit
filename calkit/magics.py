"""IPython magics."""

import os
import pickle
import subprocess

from IPython.core import magic_arguments
from IPython.core.magic import Magics, cell_magic, magics_class

import calkit


@magics_class
class Calkit(Magics):

    @magic_arguments.magic_arguments()
    @magic_arguments.argument(
        "-n", "--name", help="Stage name.", required=True
    )
    @magic_arguments.argument("--dep", help="Declare a dependency.", nargs="+")
    @magic_arguments.argument("--out", help="Declare an output.", nargs="+")
    @cell_magic
    def dvc_stage(self, line, cell):
        """Turn a notebook cell into a DVC pipeline stage.

        Note that all dependencies must be declared since the cell will be
        first turned into a script and then run as part of the DVC pipeline.

        Then variables will be loaded back into the user namespace state by
        loading the DVC output.
        """
        args = magic_arguments.parse_argstring(self.dvc_stage, line)
        # First, let's write this cell out to a script, ensuring that we
        # load the important state at the top
        script_txt = "# This script was automatically generated by Calkit\n\n"
        script_txt += "import calkit\n"
        if args.dep:
            for d in args.dep:
                stage, varname = d.split(":")
                script_txt += (
                    f"{varname} = calkit.load_notebook_stage_out("
                    f"stage_name='{stage}', out_name='{varname}')\n\n"
                )
        script_txt += cell
        for out in args.out:
            if out in self.shell.user_ns:
                print("Found", out)
        # Add lines that save our outputs to files
        if args.out:
            for out in args.out:
                script_txt += (
                    f"calkit.save_notebook_stage_out("
                    f"{out}, stage_name='{args.name}', out_name='{out}')\n"
                )
        # Save the script to a Python file
        script_fpath = calkit.get_notebook_stage_script_path(args.name)
        script_dir = os.path.dirname(script_fpath)
        os.makedirs(script_dir, exist_ok=True)
        with open(script_fpath, "w") as f:
            f.write(script_txt)
        # Create a DVC stage that runs the script, defining the appropriate
        # dependencies and outputs, and run it
        cmd = [
            "dvc",
            "stage",
            "add",
            "-n",
            args.name,
            "--run",
            "--force",
            "-d",
            script_fpath,
        ]
        if args.dep:
            for dep in args.dep:
                stage, varname = dep.split(":")
                cmd += [
                    "-d",
                    f".calkit/notebook-stages/{stage}/outs/{varname}.pickle",
                ]
        if args.out:
            for out in args.out:
                cmd += [
                    "-o",
                    f".calkit/notebook-stages/{args.name}/outs/{out}.pickle",
                ]
        cmd.append(f"python '{script_fpath}'")
        subprocess.check_call(cmd)
        # Now let's read in and inject the outputs back into the IPython state
        if args.out:
            for out in args.out:
                fp = f".calkit/notebook-stages/{args.name}/outs/{out}.pickle"
                with open(fp, "rb") as f:
                    self.shell.user_ns[out] = pickle.load(f)


def load_ipython_extension(ipython):
    """Any module file that define a function named `load_ipython_extension`
    can be loaded via `%load_ext module.path` or be configured to be
    autoloaded by IPython at startup time.

    See https://ipython.readthedocs.io/en/stable/config/custommagics.html
    """
    # You can register the class itself without instantiating it
    # IPython will call the default constructor on it
    ipython.register_magics(Calkit)
